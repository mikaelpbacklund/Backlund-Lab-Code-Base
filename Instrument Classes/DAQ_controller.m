classdef DAQ_controller < instrumentType
   %DAQ_controller - Controls and manages data acquisition devices
   %
   % Features:
   %   - Automatic device detection and connection
   %   - Support for analog, digital, and counter channels
   %   - Signal/reference differentiation
   %   - Continuous and discrete data collection modes
   %
   % Usage:
   %   daq = DAQ_controller('configFileName.json');
   %   daq.connect();
   %   daq.setDataChannel(1);
   %   data = daq.readDAQData();
   %
   % Dependencies:
   %   - MATLAB Data Acquisition Toolbox
   %   - JSON configuration file with channel definitions
   %
   % See also: instrumentType, daq

   %% User Configurable Properties
   properties (Dependent)
      % Properties that can be modified by the user
      continuousCollection    % Enable/disable continuous data collection
      takeData               % Enable/disable data collection
      activeDataChannel      % Currently active data channel
      differentiateSignal    % Enable/disable signal/reference differentiation
      maxErrorCount         % Maximum number of errors before stopping
      % Data collection configuration
      scanBufferMultiplier  % Multiplier for buffer overflow detection
      minScansAvailable     % Minimum number of scans required for processing
      voltageScaleFactor    % Scale factor for voltage data conversion
      maxDataPoints         % Maximum number of data points to store
   end

   %% Internal Properties
   properties (SetAccess = {?DAQ_controller ?instrumentType}, GetAccess = public)
      % Properties managed internally by the class
      manufacturer           % DAQ device manufacturer
      analogPortNames        % Available analog port names
      digitalPortNames       % Available digital port names
      counterPortNames       % Available counter port names
      daqName               % Name of the connected DAQ device
      handshake             % DAQ device connection handle
      channelInfo           % Channel configuration information
      clockPort             % Clock port configuration
      dataChannels          % Available data channels
   end

   %% Read-only Properties
   properties (Dependent, SetAccess = {?DAQ_controller ?instrumentType}, GetAccess = public)
      % Properties that are read-only for users
      sampleRate            % Current sample rate
      toggleChannel         % Channel used for toggling data collection
      signalReferenceChannel % Channel used for signal/reference differentiation
      dataPointsTaken       % Number of data points collected
      dataAcquirementMethod % Method used for data acquisition
   end
   
   methods   

      function obj = DAQ_controller(configFileName)
          %DAQ_controller Creates a new DAQ controller instance
          %
          %   obj = DAQ_controller(configFileName) creates a new DAQ controller
          %   using the specified configuration file.
          %
          %   Throws:
          %       error - If configFileName is not provided
          
          if nargin < 1
              error('DAQ_controller:MissingConfig', 'Config file name required as input')
          end

         %Loads config file and checks relevant field names
         configFields = {'channelInfo','clockPort','manufacturer','identifier','sampleRate',...
                        'scanBufferMultiplier','minScansAvailable','maxErrorCount',...
                        'voltageScaleFactor','maxDataPoints'};
         commandFields = {};
         numericalFields = {}; %has units, conversion factor, and min/max         
         obj = loadConfig(obj,configFileName,configFields,commandFields,numericalFields);
      end
      
      function obj = connect(obj)  
         %connect Establishes connection with the DAQ device
         %
         %   obj = connect(obj) connects to the DAQ device and initializes
         %   channels and settings.
         %
         %   Throws:
         %       error - If DAQ is already connected or multiple DAQs detected
         
         if obj.connected
            error('DAQ_controller:AlreadyConnected', 'DAQ is already connected')
         end

         %Suppresses a warning generated by daq code provided by matlab
         warning('off','MATLAB:subscripting:noSubscriptsSpecified');
         
         %Checks if config channel labels are valid
         channels = squeeze(struct2cell(obj.channelInfo));
         channels = channels(strcmp(fieldnames(obj.channelInfo),'label'),:);
         
         obj.dataChannels = find(contains(lower(channels),'data'));
         obj.toggleChannel = find(contains(lower(channels),'toggle')  | contains(lower(channels),'enable'));
         obj.signalReferenceChannel = find(contains(lower(channels),'signal') | contains(lower(channels),'reference'));
         
         if isempty(obj.dataChannels)
            error('DAQ_controller:MissingDataChannel', 'Config file must contain a channel with a label containing "data"')
         end
         if numel(obj.toggleChannel) ~= 1
            error('DAQ_controller:InvalidToggleChannel', 'Config file must contain exactly 1 channel with a label containing "toggle" or "enable"')
         end
         if numel(obj.signalReferenceChannel) ~= 1
            error('DAQ_controller:InvalidSignalChannel', 'Config file must contain exactly 1 channel with a label containing "signal" or "reference"')
         end
         
         %Find non-simulated device
         devices = daqlist;
         isSimulated = [devices.DeviceInfo.IsSimulated];
         obj.daqName = devices.DeviceID(~isSimulated);

         if numel(obj.daqName) > 1
             error('DAQ_controller:MultipleDevices', 'Multiple DAQs detected')
         end
         
         %Store port names
         obj.analogPortNames = devices.DeviceInfo(~isSimulated).Subsystems(1).ChannelNames;
         obj.digitalPortNames = devices.DeviceInfo(~isSimulated).Subsystems(3).ChannelNames;
         obj.counterPortNames = devices.DeviceInfo(~isSimulated).Subsystems(4).ChannelNames;         
         
         %Create DAQ connection
         obj.handshake = daq(obj.manufacturer);
         obj.handshake.Rate = obj.sampleRate;

         obj.connected = true;
         obj.identifier = 'DAQ';
         
         %Set default values
         obj = setDataChannel(obj,1);
         obj = setContinuousCollection(obj,'on');
         obj = setSignalDifferentiation(obj,'on');
         obj.takeData = false;
         obj.toggleChannel = obj.defaults.toggleChannel;
         obj.signalReferenceChannel = obj.defaults.signalReferenceChannel;  

         %Set data collection callback
         obj.handshake.ScansAvailableFcn = @storeData;
         
         %Add channels
         for ii = 1:numel(obj.channelInfo)
            obj = addChannel(obj,obj.channelInfo(ii));    
         end 
      end
      
      function obj = disconnect(obj)
         %disconnect Disconnects from the DAQ device
         %
         %   obj = disconnect(obj) disconnects from the DAQ device and cleans up
         %   resources.
         
         if ~obj.connected    
             return;   
         end
         if ~isempty(obj.handshake)
            obj.handshake = [];
         end
         obj.connected = false;
      end
      
      function obj = addChannel(obj,channelInfo)
         %addChannel Adds a channel to the DAQ device
         %
         %   obj = addChannel(obj,channelInfo) adds a channel based on the
         %   provided configuration.
         %
         %   Required fields in channelInfo:
         %       - dataType: 'voltage', 'counter', or 'digital'
         %       - port: Port name for the channel
         %
         %   Throws:
         %       error - If required fields are missing or invalid
         
         mustContainField(channelInfo,{'dataType','port'})
         
         %Set data type and valid port names based on input type
         switch lower(channelInfo.dataType)
            case {'v','voltage','analog'}
               dataType = 'Voltage';
               portNames = 'analogPortNames';
            case {'counter','cntr','count','edge','edge count','edgecount'}
               dataType = 'EdgeCount';
               portNames = 'counterPortNames';
            case {'digital','binary'}
               dataType = 'Digital';
               portNames = 'digitalPortNames';
            otherwise
               error('DAQ_controller:InvalidDataType', ...
                   'Invalid dataType for channel %d. Must be "voltage", "counter", or "digital"',ii)
         end
         
         if ~any(strcmp(channelInfo.port,obj.(portNames)))
            error('DAQ_controller:InvalidPort', 'Invalid port name. See %s for valid names',portNames)
         end

         %Loads the indicated channel
         addinput(obj.handshake,obj.daqName,channelInfo.port,dataType)
         obj.handshake.UserData.dataType = dataType;
      end
      
      function obj = setDataChannel(obj,channelDesignation)
         %setDataChannel Sets the active data channel
         %
         %   obj = setDataChannel(obj,channelDesignation) sets the active data
         %   channel by number or name/port.
         %
         %   Throws:
         %       error - If channelDesignation is invalid
         
         %Number input
         if isa(channelDesignation,'double')
            if channelDesignation > numel(obj.channelInfo)
               error('DAQ_controller:InvalidChannelNumber', ...
                   '%d is greater than the %d channels',channelDesignation,numel(obj.channelInfo))
            end
            obj.handshake.UserData.dataChannelNumber = channelDesignation;
            obj.activeDataChannel = obj.channelInfo(channelDesignation).label;
            return
         end
         
         %Label/port input
         channelNumber = getChannelIndex(obj, channelDesignation);
         obj.activeDataChannel = obj.channelInfo(channelNumber).label;
         obj.handshake.UserData.dataChannelNumber = channelNumber;
         dataType = getDataType(obj, channelNumber);
         obj.handshake.UserData.dataType = dataType;
      end
      
      function obj = setSignalDifferentiation(obj,onOff)
         %setSignalDifferentiation Enables/disables signal/reference differentiation
         %
         %   Note: When enabled, continuous collection is automatically turned on
         
         obj.differentiateSignal = instrumentType.discernOnOff(onOff);
         if strcmp(obj.differentiateSignal,'on')
            obj.handshake.UserData.differentiateSignal = true;
            obj.continuousCollection = 'on';
         else
            obj.handshake.UserData.differentiateSignal = false;
         end
      end

      function obj = setContinuousCollection(obj,onOff)
         %setContinuousCollection Sets continuous collection mode
         %
         %   obj = setContinuousCollection(obj,onOff) enables/disables
         %   continuous data collection.
         %
         %   Throws:
         %       error - If DAQ is not connected
         
         checkConnection(obj)
         obj.continuousCollection = instrumentType.discernOnOff(onOff);
      end
      
      function obj = resetDAQ(obj)
         %resetDAQ Resets DAQ counters and data collection
         %
         %   For continuous collection: resets accumulated data
         %   For discrete collection: prepares for new data collection
         
         %If the DAQ is continuously gathering data (signal vs reference is
         %enabled AND/OR continuous is hard set) 
         if strcmp(obj.continuousCollection,'on') || strcmp(instrumentType.discernOnOff(obj.handshake.UserData.differentiateSignal),'on')
            %Set the reference and signal to 0
            obj.handshake.UserData.reference = 0;
            obj.handshake.UserData.signal = 0;
            obj.handshake.UserData.nPoints = 0;
            obj.handshake.UserData.currentCounts = 0;   
            %Turn on collection
            if ~obj.handshake.Running, start(obj.handshake,"continuous"), end     
         else
            if obj.handshake.Running, stop(obj.handshake), end
            resetcounters(obj.handshake)
         end
      end
      
      function varargout = readDAQData(obj)
         %readDAQData Reads data from the DAQ
         %
         %   [ref, sig] = readDAQData(obj) returns reference and signal values.
         %   For continuous collection with differentiation, both values are
         %   returned. For continuous collection without differentiation, only
         %   reference is returned. For discrete collection, a single value
         %   is returned.
         
         if strcmp(obj.differentiateSignal,'on')
            varargout{1} = obj.handshake.UserData.reference;
            varargout{2} = obj.handshake.UserData.signal;
         elseif strcmp(obj.continuousCollection,'on')
            varargout{1} = obj.handshake.UserData.reference;
         else
            if obj.handshake.Running,   stop(obj.handshake), end
            unsortedData = read(obj.handshake,"OutputFormat","Matrix");
            varargout{1} = unsortedData(obj.handshake.UserData.dataChannelNumber);
         end
      end
      
   end

   methods
      function obj = setParameter(obj,val,varName)         
         if obj.connected
            obj.handshake.UserData.(varName) = val;
         else
            obj.presets.(varName) = val;
         end
      end
      function val = getParameter(obj,varName)
         if obj.connected
            val =  obj.handshake.UserData.(varName);
         elseif isfield(obj.presets,varName) && ~isempty(obj.presets.(varName))
            val = obj.presets.(varName);
         elseif isfield(obj.defaults,varName) && ~isempty(obj.defaults.(varName))
            val = obj.defaults.(varName);
         else
            val  =[];
         end
      end      

      function set.continuousCollection(obj,val)
         obj = setParameter(obj,instrumentType.discernOnOff(val),'continuousCollection');
         if strcmpi(instrumentType.discernOnOff(val),'off')
             obj = setParameter(obj,'off','differentiateSignal');%#ok<NASGU>
         end
      end
      function val = get.continuousCollection(obj)
         val = getParameter(obj,'continuousCollection');
      end

      function set.takeData(obj,val)
         obj = setParameter(obj,val,'takeData'); %#ok<NASGU>
      end
      function val = get.takeData(obj)
         val = getParameter(obj,'takeData');
      end

      function set.differentiateSignal(obj,val)
         obj = setParameter(obj,instrumentType.discernOnOff(val),'differentiateSignal');
         if strcmpi(instrumentType.discernOnOff(val),'on')
             obj = setParameter(obj,'on','continuousCollection');%#ok<NASGU>
         end
      end
      function val = get.differentiateSignal(obj)
         val = getParameter(obj,'differentiateSignal');
      end

      function set.maxErrorCount(obj,val)
         obj = setParameter(obj,val,'maxErrorCount'); %#ok<NASGU>
      end
      function val = get.maxErrorCount(obj)
         val = getParameter(obj,'maxErrorCount');
      end

      function set.scanBufferMultiplier(obj,val)
         obj = setParameter(obj,val,'scanBufferMultiplier'); %#ok<NASGU>
      end
      function val = get.scanBufferMultiplier(obj)
         val = getParameter(obj,'scanBufferMultiplier');
      end

      function set.minScansAvailable(obj,val)
         obj = setParameter(obj,val,'minScansAvailable'); %#ok<NASGU>
      end
      function val = get.minScansAvailable(obj)
         val = getParameter(obj,'minScansAvailable');
      end

      function set.voltageScaleFactor(obj,val)
         obj = setParameter(obj,val,'voltageScaleFactor'); %#ok<NASGU>
      end
      function val = get.voltageScaleFactor(obj)
         val = getParameter(obj,'voltageScaleFactor');
      end

      function set.maxDataPoints(obj,val)
         obj = setParameter(obj,val,'voltageScaleFactor'); %#ok<NASGU>
      end
      function val = get.maxDataPoints(obj)
         val = getParameter(obj,'voltageScaleFactor');
      end

      function set.activeDataChannel(obj,val)
         %Sets active data channel number/name based on designation given.
         %Designation can be the channel port or channel label so long as it is unique to that channel
         if ~obj.connected
            obj.presets.activeDataChannel = val;
            return
         end
         channelNumber = getChannelIndex(obj, val);
         obj.handshake.UserData.dataChannelNumber = channelNumber;
         dataType = getDataType(obj, channelNumber);
         obj.handshake.UserData.dataType = dataType;
      end
      function val = get.activeDataChannel(obj)
         val = obj.channelInfo(getParameter(obj,'dataChannelNumber')).label;
      end

      %Properties below are read-only 
      function set.toggleChannel(obj,val)
         if ~obj.connected
            obj.presets.toggleChannel = val;
            return
         end
         channelNumber = getChannelIndex(obj, val);
         obj.handshake.UserData.toggleChannel = channelNumber;
      end
      function val = get.toggleChannel(obj)
         val = getParameter(obj,'toggleChannel');
      end

      function set.signalReferenceChannel(obj,val)
         if ~obj.connected
            obj.presets.signalReferenceChannel = val;
            return
         end
         channelNumber = getChannelIndex(obj, val);
         obj.handshake.UserData.signalReferenceChannel = channelNumber;
      end
      function val = get.signalReferenceChannel(obj)
         val = getParameter(obj,'signalReferenceChannel');
      end

      function set.sampleRate(obj,val)
         if obj.connected
            obj.handshake.Rate = val;
         else
            obj.presets.sampleRate = val;
         end
      end
      function val = get.sampleRate(obj)
         varName = 'sampleRate';
         if obj.connected
            val =  obj.handshake.Rate;
         elseif isfield(obj.presets,varName) && ~isempty(obj.presets.(varName))
            val = obj.presets.(varName);
         elseif isfield(obj.defaults,varName) && ~isempty(obj.defaults.(varName))
            val = obj.defaults.(varName);
         else
            val  =[];
         end
      end

      function val = get.dataPointsTaken(obj)
         val = getParameter(obj,'nPoints');
      end

      function val = get.dataAcquirementMethod(obj)
         val = getParameter(obj,'dataType');
      end      

   end

   methods (Access = private)
      function idx = getChannelIndex(obj, designation)
         % Returns the index of the channel matching the designation (label or port)
         channels = squeeze(struct2cell(obj.channelInfo));
         labels = channels(strcmp(fieldnames(obj.channelInfo),'label'),:);
         ports = channels(strcmp(fieldnames(obj.channelInfo),'port'),:);
         idx = find(contains(lower(labels),lower(designation)) | contains(lower(ports),lower(designation)));
         if numel(idx) ~= 1
            error('%s is an invalid channel designation. A designation must correspond to exactly 1 channel''s port or label', designation);
         end
      end

      function dataType = getDataType(obj, channelNumber)
         % Returns the data type of the specified channel
         switch lower(obj.channelInfo(channelNumber).dataType)
            case {'v','voltage','analog'}
               dataType = 'Voltage';
            case {'counter','cntr','count','edge','edge count','edgecount'}
               dataType = 'EdgeCount';
            case {'digital','binary'}
               dataType = 'Digital';
         end
      end
   end

end

function handshake = storeData(handshake,evt) %#ok<INUSD> 
    %storeData Callback function for processing DAQ data
    %
    %   Processes data when available and updates accumulated values.
    %   Handles both counter and voltage data types.
    
    try
        % Get collection info and validate data collection state
        collectionInfo = handshake.UserData;
        if ~isValidCollectionState(collectionInfo)
            return;
        end
        
        % Read data from DAQ
        [unsortedData, ~] = readDAQData(handshake);
        if isempty(unsortedData)
            return;
        end
        
        % Process data based on type
        [sig, ref] = processData(unsortedData, collectionInfo);

        if ref > 0
           assignin("base","unsortedData",unsortedData)
        end
        
        % Update handshake data
        updateHandshakeData(handshake, sig, ref, collectionInfo, unsortedData);

        % if ref ~= 0
        %  handshake.UserData.unsortedExample = unsortedData;
        % end
        
    catch ME
        handleDAQError(handshake, ME);
    end
end

function isValid = isValidCollectionState(collectionInfo)
    %isValidCollectionState Validates data collection state
    %
    %   Returns true if all required channels are configured and
    %   data collection is enabled.
    
    isValid = collectionInfo.takeData && ...
             ~isempty(collectionInfo.dataChannelNumber) && ...
             ~isempty(collectionInfo.toggleChannel) && ...
             (~isempty(collectionInfo.signalReferenceChannel) || ...
              ~collectionInfo.differentiateSignal);
end

function [unsortedData, scansAvailable] = readDAQData(handshake)
    %readDAQData Reads available data from DAQ
    %
    %   Returns raw data matrix and number of available scans.
    %   Handles buffer overflow conditions.
    
    scansAvailable = handshake.NumScansAvailable - 10;
    
    % Handle buffer overflow
    if scansAvailable > handshake.ScansAvailableFcnCount * 100
        [~] = read(handshake, scansAvailable, "OutputFormat", "Matrix");
        unsortedData = [];
        return;
    end
    
    if scansAvailable <= 10
        unsortedData = [];
        return;
    end
    
    unsortedData = read(handshake, scansAvailable, "OutputFormat", "Matrix");
end

function [sig, ref] = processData(unsortedData, collectionInfo)
    %processData Routes data to appropriate processor
    %
    %   Routes data to counter or voltage processor based on type.
    
    if strcmpi(collectionInfo.dataType, 'EdgeCount')
        [sig, ref] = processCounterData(unsortedData, collectionInfo);
    else
        [sig, ref] = processVoltageData(unsortedData, collectionInfo);
    end
end

function [sig, ref] = processCounterData(unsortedData, collectionInfo)
    %processCounterData Processes counter data
    %
    %   Handles signal/reference differentiation for counter data.
    %   Validates counts and discards negative values.
    
    counterDifference = diff(unsortedData(:, collectionInfo.dataChannelNumber));
    dataOn = unsortedData(2:end, collectionInfo.toggleChannel);
    
    if ~collectionInfo.differentiateSignal
        sig = 0;
        ref = sum(counterDifference(dataOn));
    else
        signalOn = unsortedData(2:end, collectionInfo.signalReferenceChannel);
        sig = sum(counterDifference(signalOn & dataOn));
        ref = sum(counterDifference(~signalOn & dataOn));
    end
    
    % Validate counts
    if ref < 0 || sig < 0
        assignin("base", "rawDataFromDAQ", unsortedData);
        warning('DAQ_controller:NegativeCounts', 'Negative counts obtained, discarding data');
        sig = 0;
        ref = 0;
    end
end

function [sig, ref] = processVoltageData(unsortedData, collectionInfo)
    %processVoltageData Processes voltage data
    %
    %   Handles signal/reference differentiation for voltage data.
    %   Returns zero values if no data is available.
    
    dataOn = boolean(unsortedData(:, collectionInfo.toggleChannel));
    
    if ~any(dataOn)
        sig = 0;
        ref = 0;
        return;
    end
    
    if ~collectionInfo.differentiateSignal
        ref = sum(unsortedData(dataOn, collectionInfo.dataChannelNumber));
        sig = 0;
    else
        signalOn = boolean(unsortedData(:, collectionInfo.signalReferenceChannel));
        sig = sum(unsortedData(dataOn & signalOn, collectionInfo.dataChannelNumber));
        ref = sum(unsortedData(dataOn & ~signalOn, collectionInfo.dataChannelNumber));
    end
end

function updateHandshakeData(handshake, sig, ref, collectionInfo, unsortedData)
    %updateHandshakeData Updates accumulated values
    %
    %   Updates signal, reference, and point count in handshake data.
    
    handshake.UserData.reference = handshake.UserData.reference + ref;
    handshake.UserData.signal = handshake.UserData.signal + sig;
    
    if ref ~= 0
        handshake.UserData.nPoints = handshake.UserData.nPoints + ...
            sum(boolean(unsortedData(:, collectionInfo.toggleChannel)));
    elseif ~isfield(handshake.UserData, 'nPoints')
        handshake.UserData.nPoints = 0;
    end
end

function handleDAQError(handshake, ME)
    %handleDAQError Handles DAQ errors
    %
    %   Tracks error count and stops collection if max errors exceeded.
    
    if ~isfield(handshake.UserData, 'numErrors')
        handshake.UserData.numErrors = 1;
    else
        handshake.UserData.numErrors = handshake.UserData.numErrors + 1;
    end
    
    % Stop if too many errors
    if handshake.UserData.numErrors >= handshake.UserData.maxErrorCount
        error('DAQ_controller:MaxErrorsExceeded', ...
            'Maximum number of errors (%d) exceeded. Stopping data collection.', ...
            handshake.UserData.maxErrorCount);
    end
    
    rethrow(ME);
end